## 문제

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

## 입력

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

## 출력

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 예제 입력 1 복사

```
20 2
```

## 예제 출력 1 복사

```
21
```



## 풀면서 느낀점

변수 K개에 경우의 수가 모두 바뀌는 문제이니까 N = 10으로 잡고 점화식을 찾아보았다 



| N    | k=1      | k=2                       | k=3                                                          |
| ---- | -------- | ------------------------- | ------------------------------------------------------------ |
| 0    | 0        | 0+0                       | 0+0+0                                                        |
| 1    | 1        | 0+1<br />1+0              | 0+0+1<br />0+1+0<br />1+0+0                                  |
| 2    | 2        | 0+2<br />1+1<br />2+0     | 0+0+2<br />0+1+1<br />1+0+1<br />0+2+0<br />1+1+0<br />2+0+0 |
| 3    | 3        | 0+<br />1+<br />2+<br />3 | k-1의자리에서 0~N까지의 합                                   |
| 4    | 4        | 1.2.3.4....               |                                                              |
| 5    | 5        | 1.2.3.4.5...              |                                                              |
| .... | 결국 1개 | 1,2,3,4,5,..n개           | 1,3,6,10,15,,,,                                              |

점화식은  k-1 자리에서 N까지의 합을 구하면 된다.

나의 경우는 `dp[N][K]` 로 설정해주었기에 3중 for 문을 써서 조금 염려가 됬는데 인풋값도 200x200 으로 주었고, 제한시간이 2초고 충분히 돌릴 수있다.  



## 나의 코드

```python
N, K = map(int,input().split())

dp = [[0] *201 for _ in range(201)]

for i in range(201):
    dp[i][1] = 1
#[][] : [n의자리수][k의 갯수]
for i in range(1,201):  # k의 갯수
    for j in range(201):
        for z in range(j+1):
            dp[j][i] += dp[z][i-1]
            dp[j][i] %= 1000000000
print(dp[N][K])
```

