# 1463번: 1로 만들기

> 400 - 다이나믹 프로그래밍 1

[링크]: https://www.acmicpc.net/problem/1463

<br>

-----

## 📃문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

<br>

|   시간 제한    | 메모리 제한 |
| :------------: | :---------: |
| 1.5초 (python) |    128MB    |

<br>

## 📌입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

<br>

## 📌출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

<br>

## 📌힌트

10의 경우에 10 -> 9 -> 3 -> 1 로 3번 만에 만들 수 있다.

-----

<br>

## 🔍풀이

단순하게 주어진 정수를 1로 만든다면 여러 방법이 있다.

하지만 우리는 최소값을 구해야한다.

이를 위해 ***메모이제이션*** 을 통해 해결한다.

| 주어진 정수 | 1이 되는 최소 과정 | 최소 연산 횟수 | 베이스가 되는 수 |
| :---------: | :----------------: | :------------: | :--------------: |
|      1      |         -          |      0 회      |        -         |
|      2      |       2 - 1        |      1 회      |        1         |
|      3      |       3 - 1        |      1 회      |        1         |
|      4      |     4 - 2 - 1      |      2 회      |        2         |
|      5      |   5 - 4 - 2 - 1    |      3 회      |        4         |
|      6      |     6 - 3 - 1      |      2 회      |        3         |
|      7      |   7 - 6 - 3 - 1    |      3 회      |        6         |
|      8      |   8 - 4 - 2 - 1    |      3 회      |        4         |
|      9      |     9 - 3 - 1      |      2 회      |        3         |
|     10      |   10 - 9 - 3 - 1   |      3 회      |        9         |

위의 표에서 베이스가 되는 수란 주어진 정수에서 -1, %2, %3해서 나올 수 있는 정수이다.

10의 경우에는 베이스가 될 수 있는 수는 9와 5가 있다.

주어진 정수의 연산 횟수는 **베이스가 되는 수의 (연산 횟수 +1)**의 값이다. (10에서 9가 되기 위해 연산 횟수가 1회 추가되기 때문)

9의 연산 횟수는 2회, 5의 연산 횟수는 3회이므로 9의 연산 횟수에 +1을 하는 것이 최솟값이 된다.

<br>

1에서부터 시작해서 다음 수들의 베이스가 되어 연산 횟수가 추가되는 과정임을 알 수 있다.

이는 **최적화 원칙**을 만족하게 되어 **메모이제이션**으로 문제를 풀 수 있다.

<br>

## 📝코드

```python
# 주어진 정수 N
N = int(input())
# 구한 값들을 저장할 딕셔너리 - 메모이제이션
# key는 해당하는 정수
# value는 해당 정수가 1이 되기까지의 카운트
dic = {}

# 메모이제이션을 위한 함수 정의
def memo(n):
	a = 1
    # 1부터 N까지 결과 저장
    # 예시
    # N이 4라면 memo(1), memo(2), memo(3), memo(4)의 결과가 dic에 저장
	while n >= a:
        # 1일 경우는 무조건 0
		if a == 1:
			dic[1] = 0
        # 그외의 경우는 딕셔너리에
        # 현재 키값에 -1, /2, /3한 값이 있다면
        # # 그런데 1 다음부터는 무조건 있을 수 밖에 없다!
		else:
            # 빈 리스트에 해당하는 value값들을 넣어
            # 최소값을 찾는다.
			keys = []
			if (a/3) in dic:
				keys.append(dic[a/3])
			if (a / 2) in dic:
				keys.append(dic[a/2])
			if (a-1) in dic:
				keys.append(dic[a-1])
            # 그 값에 +1한 값이 현재 키값의 최소 value가 된다.
			dic[a] = min(keys)+1
        # value값이 정해지면 다음 key값을 위해
        # a의 크기를 1씩 키운다.
		a += 1
    # 모든 결과가 저장된 딕셔너리를 결과로 반환
	return dic

# 함수를 주어진 N에 대해 호출
memo(N)
# key값 N에 대한 value값 출력
print(dic[N])
```